{"version":3,"sources":["../src/watch.ts","../src/registry.ts","../src/config.ts","../src/node.ts","../src/extend.ts","../src/target.ts","../src/praxys.ts"],"sourcesContent":["/**\n * Callback function for watchers\n * @public\n */\nexport type WatchCallback = () => any;\n\n/**\n * Function to stop watching (unsubscribe)\n * @public\n */\nexport type StopFunction = () => void;\n\n/**\n * Function to be executed in a batch context\n * @public\n */\nexport type BatchCallback = () => any;\n\n/**\n * Function to be executed in an ignore context\n * @public\n */\nexport type IgnoreCallback = () => any;\n\n/**\n * Watcher interface - the object returned by createWatcher\n */\nexport interface Watcher {\n  /** Register a dependency when a property is accessed */\n  onGet: (path: string) => void;\n  \n  /** Notify watchers when a property is changed */\n  onSet: (path: string) => void;\n  \n  /** Notify watchers when a property is deleted */\n  onDelete: (path: string) => void;\n  \n  /** Set up a reactive watch function */\n  watch: (fn: WatchCallback) => StopFunction;\n  \n  /** Run a function without tracking dependencies */\n  ignore: (fn: IgnoreCallback) => any;\n  \n  /** Execute a function in batch mode */\n  batch: (fn: BatchCallback) => any;\n  \n  /** Internal state for testing */\n  __state?: WatcherState;\n}\n\n/**\n * Internal state for tracking dependencies\n */\nexport interface WatcherState {\n  tracking: {\n    activeDependency: Function | null;\n    pathDependencies: Map<string, Set<Function>>;\n    callbackPaths: Map<Function, Set<string>>;\n  };\n  mode: {\n    batchMode: boolean;\n    ignoreMode: boolean;\n  };\n  batch: {\n    pendingPaths: Set<string>;\n    batchLevel: number;\n  };\n  notification: {\n    inProgress: Set<string>;\n    unwatchedCallbacks: Set<Function>;\n  };\n}\n\n/**\n * Function to create a new watcher\n */\nexport type CreateWatcherFunction = () => Watcher; \n\n/**\n * Creates a watcher that manages reactivity for a specific node instance.\n * Each node root will have its own watcher with watch, batch, and ignore methods.\n */\nexport const createWatcher: CreateWatcherFunction = () => {\n  // Organize state into logical groups\n  const state: WatcherState = {\n    // Dependency tracking\n    tracking: {\n      activeDependency: null,\n      // Track which paths a callback depends on\n      pathDependencies: new Map(), // path -> Set of callbacks\n      // Track which paths a callback is watching\n      callbackPaths: new Map(), // callback -> Set of paths\n    },\n    // Execution modes\n    mode: {\n      batchMode: false,\n      ignoreMode: false,\n    },\n    // Batch operation state\n    batch: {\n      pendingPaths: new Set(),\n      // Track the nesting level\n      batchLevel: 0,\n    },\n    // Notification management\n    notification: {\n      inProgress: new Set(),\n      unwatchedCallbacks: new Set(),\n    }\n  };\n\n  /**\n   * Helper to run callbacks safely\n   * Note: collectionSet is always provided in the current implementation, which is why \n   * there's no 'else' branch for direct execution (it would be unreachable code).\n   * Also, callbacks is always a Set from pathDependencies and never null.\n   */\n  function runCallbacks(callbacks: Set<Function>, collectionSet: Set<Function> | null = null): void {\n    callbacks.forEach((fn) => {\n      if (!state.notification.unwatchedCallbacks.has(fn)) {\n        if (collectionSet) {\n          collectionSet.add(fn);\n        }\n      }\n    });\n  }\n\n  /**\n   * Helper to add a dependency between a callback and a path\n   */\n  function addDependency(path: string, callback: Function): void {\n    // Add to path dependencies\n    if (!state.tracking.pathDependencies.has(path)) {\n      state.tracking.pathDependencies.set(path, new Set());\n    }\n    const callbacks = state.tracking.pathDependencies.get(path)!;\n    callbacks.add(callback);\n\n    // Track paths for this callback\n    if (!state.tracking.callbackPaths.has(callback)) {\n      state.tracking.callbackPaths.set(callback, new Set());\n    }\n    const paths = state.tracking.callbackPaths.get(callback)!;\n    paths.add(path);\n  }\n\n  /**\n   * Helper to remove a dependency between a callback and a path\n   */\n  function removeDependency(path: string, callback: Function): void {\n    // Remove from path dependencies\n    if (state.tracking.pathDependencies.has(path)) {\n      const callbacks = state.tracking.pathDependencies.get(path)!;\n      callbacks.delete(callback);\n      if (callbacks.size === 0) {\n        state.tracking.pathDependencies.delete(path);\n      }\n    }\n  }\n\n  /**\n   * Register a dependency on a specific path\n   */\n  function onGet(path: string): void {\n    if (state.tracking.activeDependency) {\n      // Add to path dependencies\n      addDependency(path, state.tracking.activeDependency);\n    }\n  }\n\n  /**\n   * Helper to add a path to the batch queue\n   */\n  function addToBatch(path: string): void {\n    state.batch.pendingPaths.add(path);\n  }\n\n  /**\n   * Notify watchers when a path has changed\n   */\n  function notify(path: string): void {\n    // If in ignore mode, don't trigger notifications\n    if (state.mode.ignoreMode) return;\n\n    // If in batch mode, collect notifications to process later\n    if (state.mode.batchMode) {\n      addToBatch(path);\n      return;\n    }\n\n    // Prevent recursive notifications\n    if (state.notification.inProgress.has(path)) return;\n    state.notification.inProgress.add(path);\n\n    try {\n      // Notify only dependencies that exactly match this path\n      const callbacksToRun = new Set<Function>();\n      \n      // Find all callbacks that depend directly on this exact path\n      if (state.tracking.pathDependencies.has(path)) {\n        const callbacks = state.tracking.pathDependencies.get(path)!;\n        runCallbacks(callbacks, callbacksToRun);\n      }\n\n      // Run the callbacks\n      callbacksToRun.forEach(fn => fn());\n    } finally {\n      state.notification.inProgress.delete(path);\n    }\n  }\n\n  /**\n   * Notify watchers when a property is changed\n   */\n  function onSet(path: string): void {\n    notify(path);\n  }\n\n  /**\n   * Notify watchers when a property is deleted\n   */\n  function onDelete(path: string): void {\n    notify(path);\n  }\n\n  /**\n   * Set up a reactive watch with this watcher's state\n   */\n  function watch(callback: WatchCallback): StopFunction {\n    const runFn = () => {\n      state.tracking.activeDependency = runFn;\n\n      try {\n        callback();\n      } finally {\n        state.tracking.activeDependency = null;\n      }\n    };\n\n    runFn(); // Initial run\n\n    // Return a stop function\n    return () => {\n      // Mark as unwatched to prevent further calls\n      state.notification.unwatchedCallbacks.add(runFn);\n\n      // Clean up dependencies\n      if (state.tracking.callbackPaths.has(runFn)) {\n        const paths = state.tracking.callbackPaths.get(runFn)!;\n        \n        // Remove this callback from all path dependencies\n        paths.forEach(path => {\n          removeDependency(path, runFn);\n        });\n        \n        // Remove tracked paths\n        state.tracking.callbackPaths.delete(runFn);\n      }\n    };\n  }\n\n  /**\n   * Run a function without tracking dependencies\n   */\n  function ignore(fn: IgnoreCallback): void {\n    const previousIgnoreMode = state.mode.ignoreMode;\n    state.mode.ignoreMode = true;\n\n    try {\n      return fn();\n    } finally {\n      state.mode.ignoreMode = previousIgnoreMode;\n    }\n  }\n\n  /**\n   * Execute a function in batch mode\n   */\n  function batch(fn: BatchCallback): void {\n    // Track batch nesting level\n    state.batch.batchLevel++;\n\n    // Only initialize batch state at the top level\n    const isTopLevelBatch = state.batch.batchLevel === 1;\n    if (isTopLevelBatch) {\n      state.mode.batchMode = true;\n    }\n\n    try {\n      // Run the function in batch mode\n      const result = fn();\n\n      // Only process notifications if we're exiting the top-level batch\n      state.batch.batchLevel--;\n      if (isTopLevelBatch) {\n        processBatchNotifications();\n      }\n\n      return result;\n    } catch (e) {\n      // Clean up on error - make sure to decrement batch level\n      state.batch.batchLevel--;\n\n      // Reset batch state if we're at the top level\n      if (isTopLevelBatch) {\n        state.mode.batchMode = false;\n        state.batch.pendingPaths.clear();\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Process all pending notifications in batch mode\n   */\n  function processBatchNotifications(): void {\n    state.mode.batchMode = false;\n\n    // Collect all unique callbacks that need to be notified\n    const callbacksToRun = new Set<Function>();\n\n    // Find all callbacks that depend on any of the pending paths\n    state.batch.pendingPaths.forEach(changedPath => {\n      // Only notify callbacks that directly depend on the exact path that changed\n      if (state.tracking.pathDependencies.has(changedPath)) {\n        const callbacks = state.tracking.pathDependencies.get(changedPath)!;\n        runCallbacks(callbacks, callbacksToRun);\n      }\n    });\n\n    // Run each callback exactly once\n    callbacksToRun.forEach((fn) => fn());\n\n    // Clean up\n    state.batch.pendingPaths.clear();\n  }\n\n  const watcher: Watcher = {\n    onGet,\n    onSet,\n    onDelete,\n    watch,\n    ignore,\n    batch,\n  };\n\n  // Expose internal state for testing only in test environment\n  if (process.env.NODE_ENV === 'test') {\n    (watcher as any).__state = state;\n  }\n\n  return watcher;\n}\n","/**\n * Plugin type definition\n * For type-level documentation only\n */\nexport interface Plugin<Ctx, Utils, Opts, Props> {\n  context:    Ctx\n  utilities:  Utils\n  options:    Opts\n  properties: Props\n}\n\n/**\n * Plugin function signature\n */\nexport type PluginFunction = (args: any) => any;\n\n/**\n * Registry for storing plugin functions\n */\nexport interface Registry {\n  /** Register a plugin with the system */\n  register: (key: string, pluginFn: PluginFunction) => void;\n  \n  /** Resolve a plugin function by key */\n  resolve: (key: string) => Function | undefined;\n} \n\n// Runtime storage of plugin functions\nexport const plugins = new Map<string, Function>();\n\n/**\n * Register a plugin at runtime.\n */\nexport function register(key: string, pluginFn: PluginFunction): void {\n  // check if the key is falsy\n  if (!key) {\n    throw new Error('Invalid plugin key');\n  }\n\n  if (plugins.has(key)) {\n    throw new Error(`Plugin ${key} already registered`);\n  }\n  plugins.set(key, pluginFn);\n}\n\n/** \n * Pulls out the raw Function for runtime use\n */\nexport function resolve(key: string): Function | undefined {\n  return plugins.get(key);\n}\n","import { extend, ExtensionArgs, ExtensionFunction } from './extend';\nimport { resolve } from './registry';\n\n/**\n * Plugin configuration entry\n * @internal\n */\ninterface PluginConfig {\n  /** Name of the plugin */\n  name: string;\n  /** Options to pass to the plugin */\n  opts: any;\n}\n\n/**\n * Configuration chain\n * @internal\n */\ninterface ConfigChain {\n  /** Path for this configuration chain */\n  _path: string;\n  /** Plugins configured in this chain */\n  _plugins: PluginConfig[];\n}\n\n/**\n * Configuration proxy returned by the config() function\n */\ndeclare global {\n  namespace Plugins {\n    interface Config {\n      /** All configuration chains */\n      _chains: ConfigChain[];\n      /** Use another configuration */\n      use(otherConfig: Config): Config;\n      /** Dynamic property access creates new chains */\n      [key: string]: any;\n    }\n  }\n}\n\n/**\n * Type alias for Plugins.Config\n * @internal\n */\ntype Config = Plugins.Config;\n\n/**\n * Arguments for the processConfig function\n * @internal\n */\ninterface ProcessConfigArgs {\n  /** Configuration object */\n  config: Config;\n  /** Current path in the object tree */\n  path: string;\n  /** Node being processed */\n  node?: any;\n  /** State object */\n  state?: any;\n  /** Root object reference */\n  root?: any;\n  /** Plugin options */\n  opts?: any;\n  /** Other properties */\n  [key: string]: any;\n}\n\n/**\n * Creates a configuration builder with chainable API\n * @type {ConfigFunction}\n */\nfunction config(): Plugins.Config {\n  const chains: ConfigChain[] = [];\n\n  /**\n   * Creates a chainable proxy for configuration\n   */\n  function chainProxy(pathArr: string[], chain: ConfigChain): any {\n    // Create a function that contains all the logic that was previously in the apply handler\n    const configFn = function () {\n      // Create a safe string version of the method name\n      let methodName = String(pathArr[pathArr.length - 1]);\n      let parentPathArr = pathArr.slice(0, -1);\n      let parentPath = parentPathArr.map(String).join('.');\n\n      // Namespace support: check for namespaced methods in the store\n      if (!resolve(methodName)) {\n        for (let i = pathArr.length - 2; i >= 1; i--) { // skip '$' at index 0\n          const nsName = pathArr.slice(i, pathArr.length).map(String).join('.');\n          if (resolve(nsName)) {\n            methodName = nsName;\n            parentPathArr = pathArr.slice(0, i);\n            parentPath = parentPathArr.map(String).join('.');\n            break;\n          }\n        }\n      }\n\n      // Throw if the method is not registered\n      if (!resolve(methodName)) {\n        throw new Error(`Method ${methodName} not found`);\n      }\n\n      chain._path = parentPath;\n      chain._plugins.push({ \n        name: methodName, \n        opts: arguments[0] // Store options with consistent naming\n      });\n      return chainProxy(parentPathArr, chain);\n    };\n\n    return new Proxy(configFn, {\n      get(_, prop) {\n        // Special properties should return accurate information\n        if (prop === '_path') return chain._path;\n        if (prop === '_plugins') return chain._plugins;\n        if (prop === '_chains') return chains;\n\n        // Extend the path for property chaining\n        const newPathArr = [...pathArr, prop as string];\n        return chainProxy(newPathArr, chain);\n      }\n    });\n  }\n\n  return new Proxy({} as Config, {\n    get(_, prop) {\n      if (prop === '_chains') return chains;\n      \n      // Handle the use method to merge configurations\n      if (prop === 'use') {\n        return function(this: Config, otherConfig: Config) {\n          // Merge chains from the other config\n          if (otherConfig._chains) {\n            for (const otherChain of otherConfig._chains) {\n              // Create a new chain with the same path\n              const chainCopy: ConfigChain = {\n                _path: otherChain._path,\n                _plugins: []\n              };\n              \n              // Add all plugins with their original options (no deep copy)\n              for (const plugin of otherChain._plugins) {\n                chainCopy._plugins.push({\n                  name: plugin.name,\n                  opts: plugin.opts // Preserve original options without copying\n                });\n              }\n\n              // Add the chain to our chains\n              chains.push(chainCopy);\n            }\n          }\n          \n          // Return this config for chaining\n          return this;\n        };\n      }\n      \n      // Start a new chain for each first-level property\n      const chain: ConfigChain = { _path: `$.${String(prop)}`, _plugins: [] };\n      chains.push(chain); // Add the chain to the chains array\n      return chainProxy(['$', prop as string], chain);\n    },\n  });\n}\n\n/**\n * Process configuration and apply it to the target\n */\nfunction processConfig(args: ProcessConfigArgs): void {\n  const { config, path } = args;\n  if (!config._chains?.length) return;\n  \n  // Build up extensions for the node by running the plugins in the chains\n  // That match the configuration provided by the user\n  const chains = config._chains\n    .filter(chain => path.startsWith(chain._path));\n  \n  if (!chains?.length) return;  \n\n  for (const chain of chains) {\n    const targeters = chain._plugins.filter(plugin => plugin.name === 'target');\n    const hasTargeters = targeters.length > 0;\n    const isExactPath = chain._path === path;\n\n    if (!hasTargeters && !isExactPath) continue;\n\n    let isTargeted = true;\n\n    for (const targeter of targeters) {\n      const targetPlugin = resolve('target');\n      if (!targetPlugin) {\n        throw new Error('Target plugin not found but targeting was specified');\n      }\n      \n      const targetFunc = targetPlugin(args);\n      const targeted = targetFunc(targeter.opts);\n      if (!targeted) {\n        isTargeted = false;\n        break;\n      }\n    }\n\n    if (!isTargeted) continue;\n\n    for (const plug of chain._plugins) {\n      if (plug.name === 'target') continue;\n\n      const { name, opts } = plug;\n      // Handle both direct plugin names and namespaced plugins\n      const pluginFn = resolve(name);\n\n      if (!pluginFn) {\n        throw new Error(`Plugin ${name} not found`);\n      }\n\n      // Create the opts function that the extend plugin expects\n      args.opts = function(innerArgs: ExtensionArgs) {\n        innerArgs.opts = opts;\n        return pluginFn(innerArgs);\n      };\n\n      extend(args as { opts: ExtensionFunction } & ExtensionArgs);\n    }\n  }\n}\n\n// export for consumers and testing\nexport { config, processConfig };","import { createWatcher } from './watch';\nimport { processConfig } from './config';\nimport type { WatchCallback, StopFunction, BatchCallback, IgnoreCallback, Watcher } from './watch';\n\n/**\n * NodeOptions defines the parameters for creating a new node\n */\nexport interface NodeOptions {\n  /** Configuration object for the node */\n  config: any;\n  /** State/data of the node */\n  state: Record<string, any>;\n  /** Root node of the tree (for nested nodes) */\n  root?: Record<string, any>;\n  /** Parent node (for nested nodes) */\n  parent?: Record<string, any>;\n  /** Path to this node in the tree */\n  path?: string;\n  /** Context object shared across nodes */\n  ctx?: Record<string, any>;\n  /** Utility functions available to the node */\n  utils?: Record<string, any>;\n}\n\n/**\n * NodeInstance represents a proxied node instance\n * @internal\n */\nexport interface NodeInstance extends Record<string, any> {\n  /** Watch for changes in the state */\n  watch: (callback: WatchCallback) => StopFunction;\n  /** Batch multiple changes into a single update */\n  batch: (fn: BatchCallback) => void;\n  /** Ignore a function from dependency tracking */\n  ignore: (fn: IgnoreCallback) => void;\n  /** Convert the node to a plain JSON object */\n  toJSON: () => Record<string, any>;\n}\n\n/**\n * Collection of WeakMaps and WeakSets used to track node instances\n */\nexport interface NodeTracker {\n  /** All node instances */\n  instances: WeakSet<any>;\n  /** Map from source objects to their node instances */\n  sources: WeakMap<any, any>;\n  /** Map from nodes to their watchers */\n  watchers: WeakMap<any, Watcher>;\n  /** Map from nodes to their extensions */\n  extensions: WeakMap<any, Map<string, PropertyDescriptor>>;\n  /** Map from nodes to their references */\n  references: WeakMap<any, Set<string>>;\n}\n\n/**\n * Type utility to mark a property as non-reactive \n * \n * This is purely for documentation purposes to indicate that\n * a property will be implemented using the Ref pattern and\n * will not trigger reactivity when accessed or modified.\n * \n * @example\n * ```typescript\n * interface Properties {\n *   id: Ref<string>; // Indicates a non-reactive property\n * }\n * ```\n * @public\n */\nexport type Ref<T> = T;\n\n/**\n * Utility type to mark properties as Ref pattern\n * \n * This transforms properties to use the Ref pattern where a property\n * like 'id' is exposed as 'idRef' in the extension but as 'id' on the node.\n */\nexport type Refs<T, K extends Array<keyof T>> = {\n  [P in keyof T as P extends K[number] ? `${string & P}Ref` : P]: T[P];\n};\n\n\n// track instances of node\nexport const instances: WeakSet<any> = new WeakSet();\n\n// track sources to their instances\nexport const sources: WeakMap<any, any> = new WeakMap();\n\n// track watcher instances\nexport const watchers: WeakMap<any, Watcher> = new WeakMap();\n\n// Store extensions for specific nodes\nexport const extensions: WeakMap<any, Map<string, PropertyDescriptor>> = new WeakMap();\n\n// Store refs for specific nodes\nexport const references: WeakMap<any, Set<string>> = new WeakMap();\n\n// helper to check if a value should be returned as is\nexport function validNodeState(state: unknown): boolean {\n  const isObject = Object.prototype.toString.call(state) === '[object Object]';\n  const isArray = Array.isArray(state);\n\n  const isNotPlainObjectOrArray = !isObject && !isArray;\n  if (isNotPlainObjectOrArray) return false;\n\n  return true;\n}\n\nexport function node(options: NodeOptions): NodeInstance | any {\n  const { config, state, root, parent, path = \"$\", ctx = {}, utils = {} } = options;\n  \n  if (instances.has(state)) {\n    return state;\n  }\n\n  if (sources.has(state)) {\n    return sources.get(state);\n  }\n\n  if (!validNodeState(state)) {\n    return state;\n  }\n\n  const proxy = new Proxy(state, {\n    get(target: Record<string, any>, prop: string | symbol): any {\n      // If it's a symbol, return it as is\n      if (typeof prop === 'symbol') {\n        return Reflect.get(target, prop);\n      }\n\n      let value = target[prop as keyof typeof target];\n    \n      // Check for extensions\n      const nodeExtensions = extensions.get(proxy);\n      if (nodeExtensions && nodeExtensions.has(prop as string)) {\n        const descriptor = nodeExtensions.get(prop as string);\n        if (descriptor && descriptor.get) {\n          // Getters are already bound, so just call directly\n          value = descriptor.get();\n        } else if (descriptor && 'value' in descriptor) {\n          // Return value properties directly\n          value = descriptor.value;\n        }\n      }\n\n      // If it's a function or in references, return it as is\n      const refs = references.get(proxy);\n      if (typeof value === 'function' || (refs && refs.has(prop as string))) {\n        return value;\n      }\n\n      const nextProp = !isNaN(Number(prop)) ? `[${String(prop)}]` : `.${String(prop)}`;\n      const nextPath = `${path}${nextProp}`;\n\n      // Notify the watcher that a value has been accessed\n      const watcher = watchers.get(root || proxy);\n      if (watcher) {\n        watcher.onGet(nextPath);\n      }\n\n      // Update the context path and parent\n      value = node({ \n        state: value, \n        config,\n        root: root || proxy, \n        parent: proxy, \n        path: nextPath, \n        ctx, \n        utils \n      });\n\n      return value;\n    },\n    set(target: Record<string, any>, prop: string | symbol, value: any): boolean {\n      // Check for extensions\n      const nodeExtensions = extensions.get(proxy);\n      if (nodeExtensions && nodeExtensions.has(prop as string)) {\n        const descriptor = nodeExtensions.get(prop as string);\n        if (descriptor && descriptor.set) {\n          // Setters are already bound, so just call directly\n          descriptor.set(value);\n        } else if (descriptor && 'value' in descriptor) {\n          // Set the value directly if it's a value property\n          descriptor.value = value;\n        }\n      } else {\n        // Set the value directly if it's not an extension\n        target[prop as keyof typeof target] = value;\n      }\n\n      // If there's a reference skip the watcher\n      const refs = references.get(proxy);\n      if (refs && refs.has(prop as string)) {\n        return true;\n      }\n      \n      // Calculate the path for this property\n      const nextProp = !isNaN(Number(prop)) ? `[${String(prop)}]` : `.${String(prop)}`;\n      const propPath = `${path}${nextProp}`;\n\n      const watcher = watchers.get(root || proxy);\n      if (watcher) {\n        watcher.onSet(propPath);\n      }\n      \n      return true;\n    },\n    deleteProperty(target: Record<string, any>, prop: string | symbol): boolean {\n      // Calculate the path for this property\n      const nextProp = !isNaN(Number(prop)) ? `[${String(prop)}]` : `.${String(prop)}`;\n      const propPath = `${path}${nextProp}`;\n      \n      delete target[prop as keyof typeof target];\n      \n      // Use a local variable to reference receiver since it's not a parameter\n      const watcher = watchers.get(root || proxy);\n      if (watcher) {\n        watcher.onDelete(propPath);\n      }\n\n      const refs = references.get(proxy);\n      if (refs && refs.has(prop as string)) {\n        refs.delete(prop as string);\n      }\n      return true;\n    },\n    has(target: Record<string, any>, prop: string | symbol): boolean {\n      // Check if it's an extension property\n      const nodeExtensions = extensions.get(proxy);\n      if (nodeExtensions && nodeExtensions.has(prop as string)) {\n        return true;\n      }\n      // Otherwise check the target\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target: Record<string, any>): ArrayLike<string | symbol> {\n      // Get regular keys\n      const regularKeys = Reflect.ownKeys(target);\n      \n      // Get extension keys\n      const nodeExtensions = extensions.get(proxy);\n      if (!nodeExtensions) {\n        return regularKeys;\n      }\n      \n      // Combine the regular keys with extension keys\n      const extKeys = Array.from(nodeExtensions.keys());\n      \n      // Return unique keys\n      return [...new Set([...regularKeys, ...extKeys])];\n    },\n    getOwnPropertyDescriptor(target: Record<string, any>, prop: string | symbol): PropertyDescriptor | undefined {\n      // Check extensions first\n      const nodeExtensions = extensions.get(proxy);\n      if (nodeExtensions && nodeExtensions.has(prop as string)) {\n        // Use the stored descriptor but ensure it's configurable\n        const descriptor = nodeExtensions.get(prop as string);\n        return { ...descriptor, configurable: true };\n      }\n      \n      // Otherwise return the regular descriptor\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    }\n  });\n\n  // If this is the root node, create a watcher and define the methods\n  if (!root) {\n    const watcher = createWatcher();\n    watchers.set(proxy, watcher);\n\n    for(const method of ['watch', 'batch', 'ignore'] as const) {\n      Object.defineProperty(proxy, method, {\n        value: watcher[method],\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n\n  // Add toJSON method\n  Object.defineProperties(proxy, {\n    toJSON: {\n      value: function() {\n        const result: Record<string, any> = Array.isArray(state) ? [] : {};\n        for (const [key, value] of Object.entries(state)) {\n          if (value && typeof value === 'object') {\n            if (sources.has(value)) {\n              const nodeValue = sources.get(value);\n              result[key] = nodeValue.toJSON();\n            } else {\n              result[key] = JSON.parse(JSON.stringify(value));\n            }\n          } else {\n            result[key] = value;\n          }\n        }\n        return result;\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  });\n\n  // Mark this as a node instance and remember its source\n  instances.add(proxy);\n  sources.set(state, proxy);\n  references.set(proxy, new Set());\n  extensions.set(proxy, new Map());\n\n  // Apply extenders\n  if (config) {\n    processConfig({ config, path, state, node: proxy, root: root || proxy, parent, ctx, utils });\n  }\n\n  // Access all the props to initialize\n  for(const prop in state) {\n    proxy[prop];\n  }\n\n  // Return the proxy\n  return proxy as NodeInstance;\n}","import { extensions, references } from './node';\nimport { register, resolve } from './registry';\n\n/**\n * Plugin extension context\n * @internal\n */\nexport interface ExtensionArgs {\n  /** The node being extended */\n  node: any;\n  /** The state of the node */\n  state: any;\n  /** The path of the node in the tree */\n  path?: string;\n  /** Any additional options passed to the plugin */\n  opts?: any;\n  /** The root node of the tree */\n  root?: any;\n  /** The parent node */\n  parent?: any;\n  /** Context object */\n  ctx?: any;\n  /** Utility functions */\n  utils?: Record<string, any>;\n}\n\n/**\n * Extension function that returns properties to add to the node\n * @internal\n */\nexport type ExtensionFunction = (context: ExtensionArgs) => Record<string, any> | null;\n\n/**\n * Options for extend plugin\n * @internal\n */\nexport type Options = ExtensionFunction;\n\n/**\n * By Plugin convention we extend the Config object to type the config chaing\n * and export Node, State, Utils, and Ctx interfaces to describe any modifications made\n * so that userland developers can type extension and plugin arguments.\n */\ndeclare global {\n  namespace Plugins {\n    interface Config {\n      extend(options: Options): Config;\n    }\n  }\n}\n\n// Empty interfaces for plugin authors to extend\nexport interface Node {}\nexport interface State {}\nexport interface Utils {}\nexport interface Ctx {}\n\n/**\n * Extend the node with the given function\n * @param {Object} params - Combined options and extension arguments\n */\nexport function extend(params: { opts: ExtensionFunction } & ExtensionArgs): any {\n  const { opts: extendFn, node, ...rest } = params;\n  \n  // Call the extension function with the correct arguments\n  const nodePrototype = extendFn({ node, ...rest });\n\n  // If no extensions were added, return the node as is\n  if (!nodePrototype) return node;\n\n  // Get the descriptors of the extensions\n  const descriptors = Object.getOwnPropertyDescriptors(nodePrototype);\n\n  // Get existing extensions or create new one\n  const extensionsMap = extensions.get(node) || new Map();\n\n  // Special handling for toJSON if provided by the extension\n  if (descriptors.toJSON) {\n    // Store the original toJSON from the node\n    const originalToJSON = node.toJSON;\n\n    // Create a new toJSON that merges the results\n    const pluginToJSON = descriptors.toJSON.value;\n\n    Object.defineProperty(node, 'toJSON', {\n      value: function () {\n        // Call both and merge the results, with plugin taking precedence\n        const baseResult = originalToJSON.call(this);\n        const pluginResult = pluginToJSON ? pluginToJSON.call(this) : {};\n        return { ...baseResult, ...pluginResult };\n      },\n      enumerable: false,\n      configurable: true,\n      writable: true\n    });\n\n    // Remove toJSON from descriptors to prevent it from being processed again\n    delete descriptors.toJSON;\n  }\n\n  // Store full descriptors\n  for (const [key, descriptor] of Object.entries(descriptors)) {\n    const isRef = key.endsWith('Ref');\n    const name = isRef ? key.slice(0, -3) : key;\n\n    // Bind getters and setters to node\n    if (descriptor.get) {\n      descriptor.get = descriptor.get.bind(node);\n    }\n    if (descriptor.set) {\n      descriptor.set = descriptor.set.bind(node);\n    }\n\n    if (isRef) {\n      const refs = references.get(node);\n      if (refs) {\n        refs.add(name);\n      }\n    }\n\n    extensionsMap.set(name, descriptor);\n\n    // Define ALL properties on the node, not just value properties\n    if ('value' in descriptor) {\n      // if it's a function make sure it's not enumerable\n      if (typeof descriptor.value === 'function') {\n        descriptor.enumerable = false;\n      }\n\n      // For value properties (not getters/setters), define directly on node\n      Object.defineProperty(node, key, descriptor);\n    }\n  }\n\n  // Store the extensions\n  extensions.set(node, extensionsMap);\n}\n\n// register the extend function\nregister('extend', extend);\n","import { register } from './registry';\n\n/**\n * Options for target plugin\n * @internal\n */\nexport interface TargetContext {\n  /** Current path in object tree */\n  path?: string;\n  /** Current state */\n  state: any;\n}\n\n/**\n * Function that evaluates whether a target condition is met\n * @internal\n */\nexport type TargetFunction = (context: TargetContext) => boolean;\n\n/**\n * By Plugin convention we extend the Config object to type the config chaing\n * and export Node, State, Utils, and Ctx interfaces to describe any modifications made\n * so that userland developers can type extension and plugin arguments.\n */\ndeclare global {\n  namespace Plugins {\n    interface Config {\n      target(options: boolean | TargetFunction): Config;\n    }\n  }\n}\n\n// Empty interfaces for plugin authors to extend\nexport interface Node {}\nexport interface State {}\nexport interface Utils {}\nexport interface Ctx {}\n\n/**\n * Boolean value or function that determines if targeting conditions are met\n */\nexport type Options = boolean | TargetFunction;\n\n/**\n * Plugin for conditional application of other plugins\n * - Allows targeting plugins based on path or state criteria\n */\nfunction target(args: { path?: string, state: any }) {\n  return (options: Options): boolean => {\n    return typeof options === 'boolean' ? \n      options : options({ \n        path: args.path, \n        state: args.state \n      });\n  };\n}\n\n// Register the target plugin with the registry\nregister('target', target);\n\n// Export for direct usage\nexport { target };\n\n","import { config } from \"./config\";\nimport { node } from \"./node\";\nimport type { WatchCallback, StopFunction, BatchCallback, IgnoreCallback } from './watch';\n\n/**\n * Praxys instance methods available on every store\n * @public\n */\nexport interface Praxys {\n  /** Watch for changes in the state */\n  watch: (fn: WatchCallback) => StopFunction;\n  /** Batch multiple changes into a single update */\n  batch: (fn: BatchCallback) => void;\n  /** Ignore a function from dependency tracking */\n  ignore: (fn: IgnoreCallback) => void;\n}\n\n/**\n * Create a reactive node with configuration\n * \n * @param S - Initial state object\n * @param $ - Configuration object\n * @returns A reactive node instance with Praxys methods\n * @public\n */\nexport function praxys<T extends Record<string, any> = Record<string, any>>(\n  S = {} as T, \n  $ = config()\n): T & Praxys {\n  const path = \"$\";\n  const parent = undefined;\n  const root = undefined;\n  const ctx = {};\n  const utils = {};\n\n  return node({\n    state: S,\n    config: $,\n    path,\n    parent,\n    root,\n    ctx,\n    utils,\n  }) as T & Praxys;\n}\n\n// Re-export the config function\nexport { config };\n"],"mappings":"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","names":["config","config","target","node"]}